---
slug: "formulario-avancado"
title: "Formul√°rio Avan√ßado!"
date: "01 de Junho de 2023"
subtitle: "Neste post irei criar um formul√°rio utilizando as bibliotecas React Hook Forms e Yup com Next.js e Typescript."
tags:
  - nextjs
  - frontend
  - react-hook-forms
  - yup
  - javascript
  - typescript
---

<br/>

Os formul√°rios podem ser entendidos como uma cole√ß√£o de <span>inputs</span>, <span>checkbox</span>, <span>select</span> entre outros elementos, √© atrav√©s deles conseguimos nos comunicar com o backend enviando dados. Alguns exemplos s√£o a autentica√ß√£o e login, cadastro,  envio de coment√°rios, pesquisa e etc‚Ä¶

<br/>

Uma abordagens para criar um formul√°rio √© utilizando um evento sint√©tico do react <span>onChange</span>/ <span>onSubmit</span> conforme mostra o exemplo de c√≥digo a seguir:

<br/>

```jsx

import { useState } from 'react';

export default function Form() {
  const [name, setName] = useState('');

  const handleChange = (event) => {
    setName(event.target.value);
  };

	const handleSubmit = () => {
		// valida o dado e envia para o backend
	}

  return (
    <form onSubmit={handleSubmit}>
      <label>
        Nome:
        <input 
          type="text" 
          value={name} 
          onChange={handleChange}	
        />
      </label>
      <button type="submit">Enviar</button>
    </form>
  );
}

```

<br/>

Neste exemplo o evento onChange √© disparado cada vez que um caracter √© digitado no campo <span>input</span>. 
A cada disparo do evento a fun√ß√£o  <span>handleChange</span> √© executada e o <span>state name</span> √© atualizado com um novo valor,  ou seja, se o nome digitado for Paula o componente <span>Form</span> ser√° renderizado 5 vezes. 

<br/>

Por causa desse excesso de renderiza√ß√£o uma outra solu√ß√£o √© utilizar a biblioteca <span>react-hook-forms</span>.

<br/>

Para ilustrar o uso dessa biblioteca irei criar um simples formul√°rio de cadastro, e como ponto de partida, irei utilizar o boilerplate criando no post anterior <a href="https://paularibeiro.netlify.app/posts/boilerplate-nextjs" target="__blank">link</a>

<br/>

```bash

npx create-next-app forms-example --example URL_DO_REPOSITORIO

```

<br/>

Em seguida vamos instalar as bibliotecas necess√°rias:

<br/>

```bash

npm install react-hook-form yup @hookform/resolvers

```

<br/>

‚ö†Ô∏è¬†Aten√ß√£o: Al√©m de criar o formul√°rio √© necess√°rio validar os dados que s√£o inseridos, para isso vamos utilizar a biblioteca <span>yup</span> e <span>@hookform/resolvers</span>.

<br/>

Primeiro determinamos quais os campos ser√£o necess√°rios para realizar o cadastro, no nosso exemplo ser√° necess√°rio informar o nome, sobrenome, email, senha e confirmar a senha. Com isso podemos criar a tipagem dos dados.

<br/>

```jsx

type UserRegisterForm = {
  user: {
    name: string;
    lastName: string;
    email: string;
    password: string;
    passwordConfirm: string;
  }
}

```

<br/>

Tamb√©m precisamos determinar as valida√ß√µes desses campos e suas mensagens de erro. Para isso vamos utilizar a biblioteca <span>yup</span> conforme mostra a seguir:

<br/>

```jsx

import * as yup from 'yup';

const yupSchema = yup.object({
  user: yup.object({
    name: yup
    .string()
    .required('Nome √© obrigat√≥rio'),
    lastName: yup
    .string()
    .required('Sobrenome √© obrigat√≥rio'),
    email: yup
    .string()
    .email()
    .required('Email √© obrigat√≥rio'),
    password: yup
    .string()
    .required('Senha √© obrigat√≥ria')
    .test('length', 'Senha deve ter no minimo 8 caracteres', (val) => val.length >= 8),
    passwordConfirm: yup
    .string()
    .required('Confirma√ß√£o de senha √© obrigat√≥ria')
    .oneOf([yup.ref('password')], 'Senhas n√£o s√£o iguais'),
  })
})

```

<br/>

Agora podemos criar nosso formul√°rio e utilizar a biblioteca <span>react-hooks-forms</span> 

<br/>

```jsx

import { useForm } from 'react-hook-form';

export default function Form () {
	const { register, handleSubmit } = useForm<UserRegisterForm>();

  const submitForm = ({ user }: UserRegisterForm) => {
    console.log(user)
  };

	return (
		<form onSubmit={handleSubmit(submitForm)}>
			<div>
			  <label>
			    Nome:
		      <input 
			      type="text"
		        { ...register('user.name')}
		      />
		    </label>
		  </div>
			<div>
			  <label>
			    Sobrenome:
		      <input 
			      type="text"
		        { ...register('user.lastName')}
		      />
		    </label>
		  </div>
			<div>
			  <label>
			    Email:
		      <input 
			      type="text"
		        { ...register('user.email')}
		      />
		    </label>
		  </div>
			<div>
			  <label>
			    Senha:
		      <input 
			      type="password"
		        { ...register('user.password')}
		      />
		    </label>
		  </div>
			<div>
			  <label>
			    Confirmar senha:
		      <input 
			      type="password"
		        { ...register('user.passwordConfirm')}
		      />
		    </label>
		  </div>
		  <button type="submit">Enviar</button>
		</form>
	)
}

```

<br/>

Desestruturamos de <span>useForm</span> duas fun√ß√µes <span>register</span> e <span>handleSubmit</span>.
A fun√ß√£o <span>register</span> que ir√° registrar o <span>value</span> do campo de <span>input</span>, portanto, ela √© passada sendo invocada com seu respectivo campo de <span>input</span>. Enquanto a fun√ß√£o <span>handleSubmit</span> ir√° validar os valores registrados antes de invocar a fun√ß√£o <span>submitForm</span> .

<br/>

Para ter acesso as mensagens de erro precisamos desestruturar o objeto <span>errors</span> de dentro de  <span>formState</span> de <span>useForm</span>, e para integrar com as valida√ß√µes feitas pelo esquema <span>yupSchema</span> precisamos passar o <span>resolver</span> informando nosso esquema de valida√ß√£o como par√¢metro da fun√ß√£o <span>yupResolver</span> oriunda da biblioteca <span>@hookform/resolvers/yup</span>, conforme mostra a seguir:

<br/>

```jsx

import { yupResolver } from '@hookform/resolvers/yup';

const { register, handleSubmit, formState: { errors } } = useForm<UserRegisterForm>({
  resolver: yupResolver(yupSchema)
});

```

<br/>

Agora basta adicionar a verifica√ß√£o de erro para cada <span>input</span>, e o c√≥digo do componente <span>Form</span> fica conforme mostra a seguir:

<br/>

```jsx

import { useForm } from 'react-hook-form';
import { yupResolver } from '@hookform/resolvers/yup';
import * as yup from 'yup';

type UserRegisterForm = {
  user: {
    name: string;
    lastName: string;
    email: string;
    password: string;
    passwordConfirm: string;
  }
}

const yupSchema = yup.object({
  user: yup.object({
    name: yup
    .string()
    .required('Nome √© obrigat√≥rio'),
    lastName: yup
    .string()
    .required('Sobrenome √© obrigat√≥rio'),
    email: yup
    .string()
    .email()
    .required('Email √© obrigat√≥rio'),
    password: yup
    .string()
    .required('Senha √© obrigat√≥ria')
    .test('length', 'Senha deve ter no minimo 8 caracteres', (val) => val.length >= 8),
    passwordConfirm: yup
    .string()
    .required('Confirma√ß√£o de senha √© obrigat√≥ria')
    .oneOf([yup.ref('password')], 'Senhas n√£o s√£o iguais'),
  })
})

export default function Form () {
  const { register, handleSubmit, formState: { errors } } = useForm<UserRegisterForm>({
    resolver: yupResolver(yupSchema)
  });

  const submitForm = ({ user }: UserRegisterForm) => {
    console.log(user)
    // enviar os dados para o backend!
  };

  return (
    <form onSubmit={handleSubmit(submitForm)}>
      <div>
        <label>
          Nome:
          <input 
            type="text"
            { ...register('user.name')}
          />
        </label>
        { errors && <span>{errors?.user?.name?.message}</span> }
      </div>
      <div>
        <label>
          Sobrenome:
          <input 
            type="text"
            { ...register('user.lastName')}
          />
        </label>
        { errors && <span>{errors?.user?.lastName?.message}</span> }
      </div>
      <div>
        <label>
          Email:
          <input 
            type="text"
            { ...register('user.email')}
          />
        </label>
        { errors && <span>{errors?.user?.email?.message}</span> }
      </div>
      <div>
        <label>
          Senha:
          <input 
            type="password"
            { ...register('user.password')}
          />
        </label>
        { errors && <span>{errors?.user?.password?.message}</span> }
      </div>
      <div>
        <label>
          Confirme a senha:
          <input 
            type="password"
            { ...register('user.passwordConfirm')}
          />
        </label>
        { errors && <span>{errors?.user?.passwordConfirm?.message}</span> }
      </div>
      <button type="submit">Enviar</button>
    </form>
  )
}

```

<br/>

Outras duas fun√ß√µes que podem ser desestruturadas de <span>useForm</span> s√£o <span>reset</span> e <span>watch</span>.

<br/>

```jsx

const { register, handleSubmit, formState: { errors }, reset, watch } = useForm<UserRegisterForm>({
    resolver: yupResolver(yupSchema)
});

```

<br/>

A fun√ß√£o <span>reset</span> serve para limpar os campos de inputs ap√≥s enviar os dados para o backend, ou um campo especifico passando como par√¢metro o campo de input desejado, enquanto a fun√ß√£o <span>watch</span>  monitora os valores que s√£o digitados, e assim como, o evento sint√©tico <span>onChange</span> a cada caracter digitado o componente √© renderizado.

<br/>

Por fim, note que o trecho de c√≥digo a seguir, 

<br/>

```jsx

<label>
  NOME_DA_LABEL:
  <input 
    type="text"
    { ...register('NOME_DO_CAMPO')}
  />
</label>

```

<br/>

se repete para cada campo de <span>input</span> , portanto podemos criar um componente e refatorar nosso formul√°rio. Para isso, podemos utiliza o <span>useFormContext</span> e o <span>FormProvider</span> para ter acesso a fun√ß√£o <span>register</span> dentro do nosso componente.

<br/>

No componente <span>Input</span> podemos desestruturar a fun√ß√£o <span>register</span> de <span>useFormContext</span> e receber via <span>props</span> o nome da label e o tipo e o nome do campo de input conforme mostra a seguir:

<br/>

```jsx

import { useFormContext } from 'react-hook-form';

interface InputProps {
  label: string
  filed: string
  type: string
}

export default function Input(props:InputProps) {
  const { register } = useFormContext()

  return (
    <div>
      <label>
	        {props.label}
          <input 
            type={props.type}
            { ...register(props.field)}
          />
        </label>
    </div>
  )
}

```

<br/>

Por√©m, para que o componente possa ter acesso a fun√ß√£o <span>register</span> precisamos envolver o formul√°rio com o <span>FormProvider</span> e disponibilizar os m√©todos com mostra a seguir: 

<br/>

```jsx

export default function Form () {
  const methods = useForm<UserRegisterForm>({
    resolver: yupResolver(yupSchema)
  });

  const { reset, watch, handleSubmit, formState: { errors }} = methods

  const submitForm = ({ user }: UserRegisterForm) => {
    console.log(user)
    // enviar os dados para o backend
  };

  return (
    <FormProvider { ...methods  }> 
      <form onSubmit={handleSubmit(submitForm)}>
        <div>
          <Input 
            label='Nome:'
            field='user.name'
            type='text'
          />
          { errors && <span>{errors?.user?.name?.message}</span> }
        </div>
        <div>
          <Input 
            label='Sobrenome:'
            filed='user.lastName'
            type='text'
          />
          { errors && <span>{errors?.user?.lastName?.message}</span> }
        </div>
        <div>
          <Input 
            label='Email:'
            filed='user.email'
            type='text'
          />
          { errors && <span>{errors?.user?.email?.message}</span> }
        </div>
        <div>
          <Input 
            label='Senha:'
            filed='user.password'
            type='password'
          />
          { errors && <span>{errors?.user?.password?.message}</span> }
        </div>
        <div>
          <Input 
            label='Confirme a senha:'
            filed='user.passwordConfirm'
            type='password'
          />
          { errors && <span>{errors?.user?.passwordConfirm?.message}</span> }
        </div>
        <button type="submit">Enviar</button>
      </form>
    </FormProvider>
  )
}

```

<br/>

‚ö†Ô∏è¬†Aten√ß√£o: Um ponto muito importante √© desabilitar o bot√£o de "Enviar‚Äù enquanto os dados estiverem sendo enviados para o backend, para que n√£o corra o risco do usu√°rio clicar repetidas vezes e enviar m√∫ltiplas requisi√ß√µes.

<br/>

E espero que esse post tenha sido util de alguma forma üòä.

<br/>